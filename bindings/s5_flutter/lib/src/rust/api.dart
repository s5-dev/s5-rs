// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `download_encrypted_blob_inner`, `extract_hash_from_location`, `upload_encrypted_blob_inner`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `S5ClientInner`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `fmt`, `from`, `from`

/// Generate a new 12-word BIP39 seed phrase.
String generateSeedPhrase() =>
    RustLib.instance.api.crateApiGenerateSeedPhrase();

/// Validate a BIP39 seed phrase.
bool validateSeedPhrase({required String phrase}) =>
    RustLib.instance.api.crateApiValidateSeedPhrase(phrase: phrase);

/// Derive all keys from a seed phrase.
S5Keys deriveKeys({required String phrase}) =>
    RustLib.instance.api.crateApiDeriveKeys(phrase: phrase);

/// Compute BLAKE3 hash of data.
Uint8List hashBlake3({required List<int> data}) =>
    RustLib.instance.api.crateApiHashBlake3(data: data);

/// Encrypt data with XChaCha20-Poly1305.
/// Returns: nonce (24 bytes) || ciphertext
Uint8List encryptXchacha20Poly1305(
        {required List<int> key, required List<int> plaintext}) =>
    RustLib.instance.api
        .crateApiEncryptXchacha20Poly1305(key: key, plaintext: plaintext);

/// Decrypt data with XChaCha20-Poly1305.
/// Input: nonce (24 bytes) || ciphertext
Uint8List decryptXchacha20Poly1305(
        {required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateApiDecryptXchacha20Poly1305(key: key, data: data);

/// Decrypt a chunk with XChaCha20-Poly1305 using chunk index as nonce.
Uint8List decryptChunkXchacha20Poly1305(
        {required List<int> key,
        required BigInt chunkIndex,
        required List<int> ciphertext}) =>
    RustLib.instance.api.crateApiDecryptChunkXchacha20Poly1305(
        key: key, chunkIndex: chunkIndex, ciphertext: ciphertext);

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<S5Client>>
abstract class S5Client implements RustOpaqueInterface {
  /// Create and connect a new S5 client.
  ///
  /// # Arguments
  /// * `seed_phrase` - 12-word BIP39 mnemonic
  /// * `remote_node_id` - Iroh node ID of the remote storage node
  static Future<S5Client> connect(
          {required String seedPhrase, required String remoteNodeId}) =>
      RustLib.instance.api.crateApiS5ClientConnect(
          seedPhrase: seedPhrase, remoteNodeId: remoteNodeId);

  /// Create a new directory.
  Future<void> createDirectory({required String path});

  /// Delete a file.
  Future<void> deleteFile({required String path});

  /// Disconnect from the remote node.
  Future<void> disconnect();

  /// Download a raw blob by hash (no decryption).
  Future<Uint8List> downloadBlob({required String hashHex});

  /// Download a file by path (with decryption if encrypted).
  Future<Uint8List> downloadFile({required String path});

  /// Check if a file exists.
  Future<bool> fileExists({required String path});

  /// Get a file's metadata as JSON.
  Future<String?> fileGet({required String path});

  /// Check if the client is connected.
  Future<bool> isConnected();

  /// List contents of a directory.
  Future<DirectoryListing> listDirectory({required String path});

  /// Get the iroh node ID for this client.
  String get nodeId;

  /// Get the user's public key (identity).
  String get publicKey;

  /// Test the connection by making a simple query.
  Future<String> testConnection();

  /// Upload a file with encryption.
  ///
  /// Small files (< 4KB) are stored inline in directory metadata.
  /// Larger files are encrypted with XChaCha20-Poly1305 and stored separately.
  /// Returns the FileRef as JSON.
  Future<String> uploadFile(
      {required String path,
      required String filename,
      required List<int> content,
      required String mediaType});
}

/// Directory listing result.
@freezed
sealed class DirectoryListing with _$DirectoryListing {
  const factory DirectoryListing({
    required List<FileEntry> files,
    required List<String> directories,
  }) = _DirectoryListing;
}

/// A file entry in a directory listing.
@freezed
sealed class FileEntry with _$FileEntry {
  const factory FileEntry({
    required String name,
    required String fileRefJson,
    required BigInt size,
    String? mediaType,
    int? timestamp,
  }) = _FileEntry;
}

@freezed
sealed class S5Error with _$S5Error implements FrbException {
  const S5Error._();

  const factory S5Error.invalidInput(
    String field0,
  ) = S5Error_InvalidInput;
  const factory S5Error.connectionError(
    String field0,
  ) = S5Error_ConnectionError;
  const factory S5Error.storageError(
    String field0,
  ) = S5Error_StorageError;
  const factory S5Error.fileNotFound(
    String field0,
  ) = S5Error_FileNotFound;
  const factory S5Error.cryptoError(
    String field0,
  ) = S5Error_CryptoError;
  const factory S5Error.internalError(
    String field0,
  ) = S5Error_InternalError;
}

/// All cryptographic keys derived from a seed phrase.
@freezed
sealed class S5Keys with _$S5Keys {
  const factory S5Keys({
    required String rootSecretHex,
    required String publicKeyHex,
    required String encryptionKeyHex,
    required String signingKeyHex,
    required String irohSecretKeyHex,
  }) = _S5Keys;
}
